# SPDX-FileCopyrightText: 2025 Weibo, Inc.
#
# SPDX-License-Identifier: Apache-2.0

name: Publish Image

on:
  pull_request:
    types: [closed]
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g. 1.0.29). Leave empty to bump patch from docker-compose.yml.'
        required: false
      base_ref:
        description: 'Optional base ref (tag/sha) for change detection (e.g. v1.0.28).'
        required: false
      force_modules:
        description: 'Force-build modules (comma-separated): backend,executor,executor_manager,frontend or "all".'
        required: false

env:
  GIT_REF: ${{ github.event_name == 'pull_request' && github.event.pull_request.merge_commit_sha || github.sha }}
  REF_TYPE: ${{ github.ref_type }}
  REF_NAME: ${{ github.ref_name }}
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository_owner }}

concurrency:
  group: publish-image
  cancel-in-progress: false

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    if: >
      ( github.event_name == 'pull_request' &&
        github.event.pull_request.base.ref == 'main' &&
        github.event.pull_request.merged == true &&
        contains(github.event.pull_request.title, 'Changeset version bump') ) ||
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch'

    outputs:
      new_version: ${{ steps.get_version.outputs.version }}

    steps:
      - name: Checkout code (full history for version detection)
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_REF }}
          fetch-depth: 0

      - name: Get version from docker-compose (and bump patch)
        id: get_version
        shell: bash
        env:
          VERSION_INPUT: ${{ github.event.inputs.version }}
        run: |
          set -euo pipefail

          if [ "${REF_TYPE}" = "tag" ]; then
            VERSION="${REF_NAME#v}"
            echo "Using tag version: ${VERSION}"
            echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "${VERSION_INPUT}" ]; then
            echo "Using workflow_dispatch input version: ${VERSION_INPUT}"
            echo "version=${VERSION_INPUT}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ ! -f docker-compose.yml ]; then
            echo "Error: docker-compose.yml not found"
            exit 1
          fi

          LINE=$(grep -E 'image:\s*ghcr\.io/[^/]+/wegent-backend:[0-9]+\.[0-9]+\.[0-9]+' docker-compose.yml | head -1 || true)
          if [ -z "$LINE" ]; then
            echo "Error: Could not find backend image line in docker-compose.yml"
            exit 1
          fi

          VERSION=$(echo "$LINE" | sed -E 's/.*wegent-backend:([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          if [ -z "$VERSION" ]; then
            echo "Error: Could not extract version from docker-compose.yml"
            exit 1
          fi

          echo "Current version: $VERSION"

          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          if [ ${#VERSION_PARTS[@]} -ne 3 ]; then
            echo "Error: Invalid version format '$VERSION'. Expected MAJOR.MINOR.PATCH"
            exit 1
          fi

          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          if ! [[ "$PATCH" =~ ^[0-9]+$ ]]; then
            echo "Error: PATCH '$PATCH' is not a number"
            exit 1
          fi

          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"

          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"

  determine-changes:
    runs-on: ubuntu-latest
    needs: prepare-release
    outputs:
      backend: ${{ steps.final.outputs.backend }}
      executor: ${{ steps.final.outputs.executor }}
      executor_manager: ${{ steps.final.outputs.executor_manager }}
      frontend: ${{ steps.final.outputs.frontend }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_REF }}
          fetch-depth: 0

      - name: Select comparison range for change detection
        id: compare
        shell: bash
        env:
          BASE_REF_INPUT: ${{ github.event.inputs.base_ref }}
        run: |
          set -euo pipefail

          # Ensure latest tags are available before describing release history
          git fetch --tags --force

          HEAD_REF=$(git rev-parse HEAD)
          CURRENT_TAG=""
          if [ "${REF_TYPE}" = "tag" ]; then
            CURRENT_TAG="${REF_NAME}"
          fi

          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)

          if [ -n "${BASE_REF_INPUT}" ]; then
            BASE_REF="${BASE_REF_INPUT}"
            echo "Using workflow_dispatch base_ref=${BASE_REF}."
            echo "base_ref=${BASE_REF}" >> "$GITHUB_OUTPUT"
            echo "head_ref=${HEAD_REF}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "${CURRENT_TAG}" ] && [ "${LAST_TAG}" = "${CURRENT_TAG}" ]; then
            # On tag pushes, `git describe --abbrev=0` returns the current tag.
            # We need the previous release tag for an accurate diff.
            PREV_TAG=$(git tag --sort=-creatordate | grep -v "^${CURRENT_TAG}$" | head -n 1 || true)
            if [ -n "${PREV_TAG}" ]; then
              LAST_TAG="${PREV_TAG}"
            else
              LAST_TAG=""
            fi
          fi

          if [ -n "${LAST_TAG}" ]; then
            BASE_REF="${LAST_TAG}"
            echo "Using last release tag ${LAST_TAG} as base."
          else
            if git rev-parse "${HEAD_REF}^" >/dev/null 2>&1; then
              BASE_REF=$(git rev-parse "${HEAD_REF}^")
              echo "No release tag found; using previous commit ${BASE_REF}."
            else
              BASE_REF="${HEAD_REF}"
              echo "Only one commit present; using HEAD for both base and head."
            fi
          fi

          echo "base_ref=${BASE_REF}" >> "$GITHUB_OUTPUT"
          echo "head_ref=${HEAD_REF}" >> "$GITHUB_OUTPUT"

      - name: Detect changed paths
        id: filter
        uses: dorny/paths-filter@v3.0.2
        with:
          base: ${{ steps.compare.outputs.base_ref }}
          ref: ${{ steps.compare.outputs.head_ref }}
          filters: |
            backend:
              - 'backend/**'
              - 'docker/backend/**'

            executor:
              - 'executor/**'
              - 'docker/executor/**'

            executor_manager:
              - 'executor_manager/**'
              - 'docker/executor_manager/**'

            frontend:
              - 'frontend/**'
              - 'docker/frontend/**'

      - name: Finalize change flags (support force_modules)
        id: final
        shell: bash
        env:
          FORCE_MODULES: ${{ github.event.inputs.force_modules }}
          FILTER_BACKEND: ${{ steps.filter.outputs.backend }}
          FILTER_EXECUTOR: ${{ steps.filter.outputs.executor }}
          FILTER_EXECUTOR_MANAGER: ${{ steps.filter.outputs.executor_manager }}
          FILTER_FRONTEND: ${{ steps.filter.outputs.frontend }}
        run: |
          set -euo pipefail

          backend="${FILTER_BACKEND:-false}"
          executor="${FILTER_EXECUTOR:-false}"
          executor_manager="${FILTER_EXECUTOR_MANAGER:-false}"
          frontend="${FILTER_FRONTEND:-false}"

          # On release tag pushes, always publish images even if the diff doesn't touch module paths.
          if [ "${REF_TYPE}" = "tag" ]; then
            backend=true
            executor=true
            executor_manager=true
            frontend=true
          fi

          if [ -n "${FORCE_MODULES}" ]; then
            force=$(echo "${FORCE_MODULES}" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')
            if [ "${force}" = "all" ]; then
              backend=true
              executor=true
              executor_manager=true
              frontend=true
            else
              IFS=',' read -ra parts <<< "${force}"
              for p in "${parts[@]}"; do
                case "${p}" in
                  backend) backend=true ;;
                  executor) executor=true ;;
                  executor_manager) executor_manager=true ;;
                  frontend) frontend=true ;;
                  "") ;;
                  *) echo "Unknown force module: ${p}" >&2; exit 1 ;;
                esac
              done
            fi
          fi

          echo "backend=${backend}" >> "$GITHUB_OUTPUT"
          echo "executor=${executor}" >> "$GITHUB_OUTPUT"
          echo "executor_manager=${executor_manager}" >> "$GITHUB_OUTPUT"
          echo "frontend=${frontend}" >> "$GITHUB_OUTPUT"

  build-backend:
    needs: [prepare-release, determine-changes]
    runs-on: ubuntu-latest
    permissions:
      packages: write
    if: needs.determine-changes.outputs.backend == 'true'

    steps:
      - name: Checkout code (full history for reproducible builds)
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_REF }}
          fetch-depth: 0

      - name: Set up QEMU (for multi-arch)
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push backend image (multi-arch)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/backend/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.IMAGE_PREFIX }}/wegent-backend:${{ needs.prepare-release.outputs.new_version }}
            ${{ env.IMAGE_PREFIX }}/wegent-backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-executor:
    needs: [prepare-release, determine-changes]
    runs-on: ubuntu-latest
    permissions:
      packages: write
    if: needs.determine-changes.outputs.executor == 'true'

    steps:
      - name: Checkout code (full history for reproducible builds)
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_REF }}
          fetch-depth: 0

      - name: Set up QEMU (for multi-arch)
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push executor image (multi-arch)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/executor/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.IMAGE_PREFIX }}/wegent-executor:${{ needs.prepare-release.outputs.new_version }}
            ${{ env.IMAGE_PREFIX }}/wegent-executor:${{ needs.prepare-release.outputs.new_version }}-codex
            ${{ env.IMAGE_PREFIX }}/wegent-executor:latest
            ${{ env.IMAGE_PREFIX }}/wegent-executor:latest-codex
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-executor-manager:
    needs: [prepare-release, determine-changes]
    runs-on: ubuntu-latest
    permissions:
      packages: write
    if: needs.determine-changes.outputs.executor_manager == 'true'

    steps:
      - name: Checkout code (full history for reproducible builds)
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_REF }}
          fetch-depth: 0

      - name: Set up QEMU (for multi-arch)
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push executor manager image (multi-arch)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/executor_manager/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.IMAGE_PREFIX }}/wegent-executor-manager:${{ needs.prepare-release.outputs.new_version }}
            ${{ env.IMAGE_PREFIX }}/wegent-executor-manager:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-frontend:
    needs: [prepare-release, determine-changes]
    runs-on: ubuntu-latest
    permissions:
      packages: write
    if: needs.determine-changes.outputs.frontend == 'true'

    steps:
      - name: Checkout code (full history for reproducible builds)
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_REF }}
          fetch-depth: 0

      - name: Set up QEMU (for multi-arch)
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push frontend image (multi-arch)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/frontend/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.IMAGE_PREFIX }}/wegent-web:${{ needs.prepare-release.outputs.new_version }}
            ${{ env.IMAGE_PREFIX }}/wegent-web:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  create-release-tag:
    needs:
      - prepare-release
      - determine-changes
      - build-backend
      - build-executor
      - build-executor-manager
      - build-frontend
    runs-on: ubuntu-latest
    permissions:
      contents: write
    if: >
      always() &&
      github.ref_type != 'tag' &&
      needs.prepare-release.result == 'success' &&
      (
        (needs.determine-changes.outputs.backend == 'true' && needs.build-backend.result == 'success') ||
        (needs.determine-changes.outputs.executor == 'true' && needs.build-executor.result == 'success') ||
        (needs.determine-changes.outputs.executor_manager == 'true' && needs.build-executor-manager.result == 'success') ||
        (needs.determine-changes.outputs.frontend == 'true' && needs.build-frontend.result == 'success')
      )

    steps:
      - name: Checkout code (full history + tags)
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_REF }}
          fetch-depth: 0

      - name: Create and push tag
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${{ needs.prepare-release.outputs.new_version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git fetch --tags --force

          if git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "Tag v${VERSION} already exists, skipping tag creation"
          else
            git tag -a "v${VERSION}" -m "Release version ${VERSION}"
            git push origin "v${VERSION}"
            echo "Created and pushed tag v${VERSION}"
          fi

      - name: Generate Release Notes
        id: release-notes
        uses: actions/github-script@v7
        env:
          TAG: v${{ needs.prepare-release.outputs.new_version }}
        with:
          script: |
            const tag = process.env.TAG;
            if (!tag) {
              core.setFailed('TAG env is missing; cannot generate release notes.');
              return;
            }

            try {
              const { data } = await github.rest.repos.generateReleaseNotes({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tag,
              });
              core.setOutput("tag", tag);
              core.setOutput("body", data.body || '');
            } catch (error) {
              core.setFailed(`Failed to generate release notes: ${error.message}`);
            }

      - name: Create GitHub Release
        if: steps.release-notes.outputs.tag != ''
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release-notes.outputs.tag }}
          name: Release ${{ steps.release-notes.outputs.tag }}
          body: ${{ steps.release-notes.outputs.body }}
          draft: false
          prerelease: false

  update-docker-compose:
    needs:
      - prepare-release
      - determine-changes
      - build-backend
      - build-executor
      - build-executor-manager
      - build-frontend
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    if: >
      always() &&
      github.ref_type != 'tag' &&
      needs.prepare-release.result == 'success' &&
      (
        (needs.determine-changes.outputs.backend == 'true' && needs.build-backend.result == 'success') ||
        (needs.determine-changes.outputs.executor == 'true' && needs.build-executor.result == 'success') ||
        (needs.determine-changes.outputs.executor_manager == 'true' && needs.build-executor-manager.result == 'success') ||
        (needs.determine-changes.outputs.frontend == 'true' && needs.build-frontend.result == 'success')
      )

    steps:
      - name: Checkout code from release ref (avoid drift vs main)
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_REF }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update docker-compose.yml versions (only for changed components)
        shell: bash
        env:
          VERSION: ${{ needs.prepare-release.outputs.new_version }}
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}
          CHANGED_BACKEND: ${{ needs.determine-changes.outputs.backend }}
          CHANGED_EXECUTOR: ${{ needs.determine-changes.outputs.executor }}
          CHANGED_EXECUTOR_MANAGER: ${{ needs.determine-changes.outputs.executor_manager }}
          CHANGED_FRONTEND: ${{ needs.determine-changes.outputs.frontend }}
        run: |
          set -euo pipefail

          if [ ! -f docker-compose.yml ]; then
            echo "Error: docker-compose.yml not found"
            exit 1
          fi

          if [ "${CHANGED_BACKEND}" = "true" ]; then
            echo "Updating backend image version to ${VERSION}"
            sed -i -E "s|(image:\\s*)ghcr\\.io/[^/]+/wegent-backend:[0-9]+\\.[0-9]+\\.[0-9]+|\\1${IMAGE_PREFIX}/wegent-backend:${VERSION}|g" docker-compose.yml
          else
            echo "Backend unchanged, skip updating backend image tag"
          fi

          if [ "${CHANGED_EXECUTOR}" = "true" ]; then
            echo "Updating executor image version to ${VERSION}"
            # executor image is referenced via executor_manager's EXECUTOR_IMAGE env var
            sed -i -E "s|(EXECUTOR_IMAGE=)ghcr\\.io/[^/]+/wegent-executor:[0-9]+\\.[0-9]+\\.[0-9]+(-codex)?|\\1${IMAGE_PREFIX}/wegent-executor:${VERSION}-codex|g" docker-compose.yml
          else
            echo "Executor unchanged, skip updating executor image tag"
          fi

          if [ "${CHANGED_EXECUTOR_MANAGER}" = "true" ]; then
            echo "Updating executor manager image version to ${VERSION}"
            sed -i -E "s|(image:\\s*)ghcr\\.io/[^/]+/wegent-executor-manager:[0-9]+\\.[0-9]+\\.[0-9]+|\\1${IMAGE_PREFIX}/wegent-executor-manager:${VERSION}|g" docker-compose.yml
          else
            echo "Executor manager unchanged, skip updating executor manager image tag"
          fi

          if [ "${CHANGED_FRONTEND}" = "true" ]; then
            echo "Updating frontend image version to ${VERSION}"
            sed -i -E "s|(image:\\s*)ghcr\\.io/[^/]+/wegent-web:[0-9]+\\.[0-9]+\\.[0-9]+|\\1${IMAGE_PREFIX}/wegent-web:${VERSION}|g" docker-compose.yml
          else
            echo "Frontend unchanged, skip updating frontend image tag"
          fi

      - name: Create Pull Request for docker-compose bump
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore: update docker-compose.yml to version ${{ needs.prepare-release.outputs.new_version }}"
          branch: weagent/update-docker-compose-${{ needs.prepare-release.outputs.new_version }}
          delete-branch: true
          title: "chore: update docker-compose.yml to version ${{ needs.prepare-release.outputs.new_version }}"
          body: |
            This PR updates Docker image versions in docker-compose.yml to version ${{ needs.prepare-release.outputs.new_version }}.

            ## Changes
            The following images have been built and pushed to GHCR with version ${{ needs.prepare-release.outputs.new_version }} (only modules with changes were updated):

            - Backend image: `${{ env.IMAGE_PREFIX }}/wegent-backend:${{ needs.prepare-release.outputs.new_version }}` (changed: ${{ needs.determine-changes.outputs.backend }})
            - Executor image: `${{ env.IMAGE_PREFIX }}/wegent-executor:${{ needs.prepare-release.outputs.new_version }}-codex` (changed: ${{ needs.determine-changes.outputs.executor }})
            - Executor Manager image: `${{ env.IMAGE_PREFIX }}/wegent-executor-manager:${{ needs.prepare-release.outputs.new_version }}` (changed: ${{ needs.determine-changes.outputs.executor_manager }})
            - Frontend image: `${{ env.IMAGE_PREFIX }}/wegent-web:${{ needs.prepare-release.outputs.new_version }}` (changed: ${{ needs.determine-changes.outputs.frontend }})

            ## Release Tag
            Git tag `v${{ needs.prepare-release.outputs.new_version }}` has been created and pushed (if at least one component changed).
