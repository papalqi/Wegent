# SPDX-FileCopyrightText: 2025 Weibo, Inc.
#
# SPDX-License-Identifier: Apache-2.0

import io
import logging
import subprocess
from typing import Optional, Tuple
from urllib.parse import urlparse

from sqlalchemy import create_engine, text
from sqlalchemy.orm import Session

from app.core.config import settings

logger = logging.getLogger(__name__)


def parse_database_url(database_url: str) -> dict:
    """
    Parse database URL to extract connection parameters.

    Supports formats:
    - mysql+pymysql://user:password@host:port/database
    - mysql+asyncmy://user:password@host:port/database
    """
    # Remove driver prefix
    url = database_url.replace("mysql+pymysql://", "mysql://").replace(
        "mysql+asyncmy://", "mysql://"
    )

    parsed = urlparse(url)

    return {
        "user": parsed.username or "root",
        "password": parsed.password or "",
        "host": parsed.hostname or "localhost",
        "port": parsed.port or 3306,
        "database": parsed.path.lstrip("/") if parsed.path else "task_manager",
    }


def export_database_with_mysqldump() -> Optional[io.BytesIO]:
    """
    Export database using mysqldump command.

    Returns BytesIO buffer with SQL dump, or None if mysqldump is not available.
    """
    try:
        # Check if mysqldump is available
        subprocess.run(
            ["mysqldump", "--version"],
            capture_output=True,
            check=True,
            timeout=5,
        )
    except (
        subprocess.CalledProcessError,
        FileNotFoundError,
        subprocess.TimeoutExpired,
    ):
        logger.warning(
            "mysqldump command not available, falling back to SQLAlchemy export"
        )
        return None

    # Parse database URL
    db_params = parse_database_url(settings.DATABASE_URL)

    # Build mysqldump command
    cmd = [
        "mysqldump",
        f"--user={db_params['user']}",
        f"--host={db_params['host']}",
        f"--port={db_params['port']}",
        "--single-transaction",
        "--routines",
        "--triggers",
        "--events",
        "--add-drop-table",
        db_params["database"],
    ]

    # Add password if provided (use environment variable for security)
    env = None
    if db_params["password"]:
        env = {"MYSQL_PWD": db_params["password"]}

    try:
        # Execute mysqldump
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=False,  # Capture as bytes
            check=True,
            timeout=300,  # 5 minutes timeout
            env=env,
        )

        # Create BytesIO buffer from output
        buffer = io.BytesIO(result.stdout)
        buffer.seek(0)

        logger.info(
            f"Database exported successfully using mysqldump ({len(result.stdout)} bytes)"
        )
        return buffer

    except subprocess.CalledProcessError as e:
        logger.error(f"mysqldump failed: {e.stderr.decode('utf-8', errors='ignore')}")
        return None
    except subprocess.TimeoutExpired:
        logger.error("mysqldump timed out after 5 minutes")
        return None
    except Exception as e:
        logger.error(f"Error running mysqldump: {str(e)}")
        return None


def export_database_with_sqlalchemy(db: Session) -> io.BytesIO:
    """
    Export database using SQLAlchemy (fallback method).

    This method exports table structures and data, but may not include
    all features that mysqldump provides (triggers, events, etc.).
    """
    buffer = io.BytesIO()

    try:
        # Get all table names
        result = db.execute(text("SHOW TABLES"))
        tables = [row[0] for row in result]

        # Write header
        header = f"""-- Database Export
-- Generated by Wegent Database Export Service
-- Database: {parse_database_url(settings.DATABASE_URL)['database']}
-- Export Method: SQLAlchemy

SET FOREIGN_KEY_CHECKS=0;
SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";

"""
        buffer.write(header.encode("utf-8"))

        # Export each table
        for table_name in tables:
            # Get table structure
            create_table_result = db.execute(text(f"SHOW CREATE TABLE `{table_name}`"))
            create_table_row = create_table_result.fetchone()
            if create_table_row:
                create_sql = create_table_row[1]
                buffer.write(
                    f"\n-- Table structure for table `{table_name}`\n".encode("utf-8")
                )
                buffer.write(f"DROP TABLE IF EXISTS `{table_name}`;\n".encode("utf-8"))
                buffer.write(f"{create_sql};\n\n".encode("utf-8"))

            # Get table data
            data_result = db.execute(text(f"SELECT * FROM `{table_name}`"))
            rows = data_result.fetchall()

            if rows:
                buffer.write(
                    f"-- Dumping data for table `{table_name}`\n".encode("utf-8")
                )

                # Get column names from result keys
                columns = list(data_result.keys())

                # Insert data in batches
                batch_size = 100
                for i in range(0, len(rows), batch_size):
                    batch = rows[i : i + batch_size]
                    values_list = []

                    for row in batch:
                        values = []
                        # row is a Row object, access by index
                        for idx, col in enumerate(columns):
                            val = row[idx]
                            if val is None:
                                values.append("NULL")
                            elif isinstance(val, (int, float)):
                                values.append(str(val))
                            else:
                                # Escape special characters
                                val_str = (
                                    str(val).replace("\\", "\\\\").replace("'", "\\'")
                                )
                                values.append(f"'{val_str}'")
                        values_list.append(f"({', '.join(values)})")

                    columns_str = ", ".join([f"`{col}`" for col in columns])
                    values_str = ", ".join(values_list)
                    insert_sql = f"INSERT INTO `{table_name}` ({columns_str}) VALUES {values_str};\n"
                    buffer.write(insert_sql.encode("utf-8"))

                buffer.write(b"\n")

        # Write footer
        footer = "\nSET FOREIGN_KEY_CHECKS=1;\n"
        buffer.write(footer.encode("utf-8"))

        buffer.seek(0)
        logger.info(
            f"Database exported successfully using SQLAlchemy ({buffer.getbuffer().nbytes} bytes)"
        )
        return buffer

    except Exception as e:
        logger.error(f"Error exporting database with SQLAlchemy: {str(e)}")
        raise


def export_database(db: Session) -> io.BytesIO:
    """
    Export database using the best available method.

    Tries mysqldump first, falls back to SQLAlchemy if not available.
    """
    # Try mysqldump first
    buffer = export_database_with_mysqldump()

    if buffer is not None:
        return buffer

    # Fall back to SQLAlchemy
    logger.info("Using SQLAlchemy export method (mysqldump not available)")
    return export_database_with_sqlalchemy(db)


def import_database_with_mysql(sql_content: bytes) -> Tuple[bool, Optional[str]]:
    """
    Import database using mysql command.

    Args:
        sql_content: SQL file content as bytes

    Returns:
        Tuple of (success: bool, error_message: Optional[str])
    """
    try:
        # Check if mysql command is available
        subprocess.run(
            ["mysql", "--version"],
            capture_output=True,
            check=True,
            timeout=5,
        )
    except (
        subprocess.CalledProcessError,
        FileNotFoundError,
        subprocess.TimeoutExpired,
    ):
        logger.warning("mysql command not available, falling back to SQLAlchemy import")
        return False, None

    # Parse database URL
    db_params = parse_database_url(settings.DATABASE_URL)

    # Build mysql command
    cmd = [
        "mysql",
        f"--user={db_params['user']}",
        f"--host={db_params['host']}",
        f"--port={db_params['port']}",
        db_params["database"],
    ]

    # Add password if provided (use environment variable for security)
    env = None
    if db_params["password"]:
        env = {"MYSQL_PWD": db_params["password"]}

    try:
        # Execute mysql command with SQL content as input
        result = subprocess.run(
            cmd,
            input=sql_content,
            capture_output=True,
            text=False,
            check=True,
            timeout=600,  # 10 minutes timeout for import
            env=env,
        )

        logger.info("Database imported successfully using mysql command")
        return True, None

    except subprocess.CalledProcessError as e:
        error_msg = (
            e.stderr.decode("utf-8", errors="ignore") if e.stderr else "Unknown error"
        )
        logger.error(f"mysql import failed: {error_msg}")
        return False, error_msg
    except subprocess.TimeoutExpired:
        logger.error("mysql import timed out after 10 minutes")
        return False, "Import operation timed out after 10 minutes"
    except Exception as e:
        logger.error(f"Error running mysql import: {str(e)}")
        return False, str(e)


def import_database_with_sqlalchemy(
    db: Session, sql_content: bytes
) -> Tuple[bool, Optional[str]]:
    """
    Import database using SQLAlchemy (fallback method).

    This method executes SQL statements directly, but may not handle
    all MySQL-specific features that mysql command supports.

    Args:
        db: Database session
        sql_content: SQL file content as bytes

    Returns:
        Tuple of (success: bool, error_message: Optional[str])
    """
    try:
        # Decode SQL content
        sql_text = sql_content.decode("utf-8", errors="ignore")

        # Simple SQL statement splitting
        # Split by semicolon, but be careful with string literals
        statements = []
        current_statement = ""
        in_string = False
        string_char = None
        i = 0

        while i < len(sql_text):
            char = sql_text[i]

            # Handle string literals
            if not in_string and char in ("'", '"', "`"):
                in_string = True
                string_char = char
                current_statement += char
            elif in_string:
                if char == "\\" and i + 1 < len(sql_text):
                    # Escaped character (including escaped quote)
                    current_statement += char + sql_text[i + 1]
                    i += 1
                elif char == string_char:
                    # Check for escaped quote (double quote like '' or "")
                    if i + 1 < len(sql_text) and sql_text[i + 1] == string_char:
                        current_statement += char + sql_text[i + 1]
                        i += 1
                    else:
                        # End of string
                        current_statement += char
                        in_string = False
                        string_char = None
                else:
                    current_statement += char
            elif char == ";":
                # End of statement
                statement = current_statement.strip()
                if statement and not statement.startswith("--"):
                    statements.append(statement)
                current_statement = ""
            else:
                current_statement += char

            i += 1

        # Add last statement if any
        if current_statement.strip():
            statement = current_statement.strip()
            if statement and not statement.startswith("--"):
                statements.append(statement)

        # Execute statements in a transaction
        try:
            db.begin()

            for statement in statements:
                statement = statement.strip()
                if not statement or statement.startswith("--"):
                    continue

                # Skip SET statements that might cause issues
                if (
                    statement.upper().startswith("SET ")
                    and "FOREIGN_KEY_CHECKS" in statement.upper()
                ):
                    continue

                try:
                    db.execute(text(statement))
                except Exception as e:
                    # Log but continue for some non-critical errors
                    logger.warning(f"Error executing statement: {str(e)[:200]}")
                    # Re-raise for critical errors
                    if "syntax error" in str(e).lower():
                        raise

            db.commit()
            logger.info(
                f"Database imported successfully using SQLAlchemy ({len(statements)} statements)"
            )
            return True, None

        except Exception as e:
            db.rollback()
            raise

    except Exception as e:
        logger.error(f"Error importing database with SQLAlchemy: {str(e)}")
        return False, str(e)


def import_database(db: Session, sql_content: bytes) -> Tuple[bool, Optional[str]]:
    """
    Import database using the best available method.

    Tries mysql command first, falls back to SQLAlchemy if not available.

    Args:
        db: Database session
        sql_content: SQL file content as bytes

    Returns:
        Tuple of (success: bool, error_message: Optional[str])
    """
    # Try mysql command first
    success, error = import_database_with_mysql(sql_content)

    if success:
        return True, None

    # If mysql command is not available (error is None), fall back to SQLAlchemy
    if error is None:
        logger.info("Using SQLAlchemy import method (mysql command not available)")
        return import_database_with_sqlalchemy(db, sql_content)

    # If mysql command failed, return the error
    return False, error
